<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_11) on Tue Jun 18 15:31:52 EDT 2013 -->
<TITLE>
LocalPath (Team Foundation Server 2012 SDK for Java)
</TITLE>

<META NAME="keywords" CONTENT="com.microsoft.tfs.core.clients.versioncontrol.path.LocalPath class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="LocalPath (Team Foundation Server 2012 SDK for Java)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LocalPath.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/ItemValidationError.html" title="class in com.microsoft.tfs.core.clients.versioncontrol.path"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/ServerPath.html" title="class in com.microsoft.tfs.core.clients.versioncontrol.path"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../../index.html?com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LocalPath.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.microsoft.tfs.core.clients.versioncontrol.path</FONT>
<BR>
Class LocalPath</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../../../resources/inherit.gif" ALT="extended by "><B>com.microsoft.tfs.core.clients.versioncontrol.path.LocalPath</B>
</PRE>
<HR>
<DL>
<DT><PRE>public abstract class <B>LocalPath</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<p>
 Static methods to process local (disk) paths.
 </p>
<P>

<P>
<DL>
<dt class="tagletsThreadSafety"><b><a href="../../../../../../../resources/thread-safety.html">Thread-safety</a>:</b></dt>
<dd class="tagletsThreadSafety">thread-safe</dd>
<dt class="tagletsWarning"><b>Warnings:</b></dt>
<dd class="tagletsWarning">Character case is not consistently ignored among all methods of this
          class. The host platform's conventional behavior with regards to
          case sensitivity will determine whether two strings differing only
          in case reference the same file in most methods, but a few are
          documented to only work without respect to character case. Look at
          the Javadoc of each method for details.</dd>
<dt><b>Since:</b></dt>
<dd>TEE-SDK-10.1</dd>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Comparator&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#BOTTOM_UP_COMPARATOR">BOTTOM_UP_COMPARATOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compares well-formed local path strings in a bottom-up fashion (children
 sort before their parents).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#TFS_PREFERRED_LOCAL_PATH_SEPARATOR">TFS_PREFERRED_LOCAL_PATH_SEPARATOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Comparator&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#TOP_DOWN_COMPARATOR">TOP_DOWN_COMPARATOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compares well-formed local path strings in a top-down fashion (parents
 sort before their children).</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#LocalPath()">LocalPath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#canonicalize(java.lang.String)">canonicalize</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Gets the canonical form of the given path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#check8Dot3Aliases(java.lang.String)">check8Dot3Aliases</A></B>(java.lang.String&nbsp;item)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the given item contains any 8.3 aliases and throws if it
 does.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#checkForIllegalDollarInPath(java.lang.String)">checkForIllegalDollarInPath</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method throws an InvalidPathException if there is a dollar sign
 ('$') that follows a path separator ('/' or '\') since no part of a path
 is allowed to start with a dollar sign.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/ItemValidationError.html" title="class in com.microsoft.tfs.core.clients.versioncontrol.path">ItemValidationError</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#checkLocalItem(java.lang.String, java.lang.String, boolean, boolean, boolean, boolean)">checkLocalItem</A></B>(java.lang.String&nbsp;item,
               java.lang.String&nbsp;parameterName,
               boolean&nbsp;allowNull,
               boolean&nbsp;allowWildcards,
               boolean&nbsp;allow8Dot3Paths,
               boolean&nbsp;checkReservedCharacters)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#combine(java.lang.String, java.lang.String)">combine</A></B>(java.lang.String&nbsp;parent,
        java.lang.String&nbsp;relative)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines the two given paths into one path string, using this platform's
 preferred path separator character.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#compareBottomUp(java.lang.String, java.lang.String)">compareBottomUp</A></B>(java.lang.String&nbsp;pathA,
                java.lang.String&nbsp;pathB)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compares two server paths (ordinal character comparison) placing parents
 after their children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#compareTopDown(java.lang.String, java.lang.String)">compareTopDown</A></B>(java.lang.String&nbsp;pathA,
               java.lang.String&nbsp;pathB)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compares two local paths (ordinal character comparison) placing children
 after their parents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#endsWith(java.lang.String, java.lang.String)">endsWith</A></B>(java.lang.String&nbsp;path,
         java.lang.String&nbsp;suffix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#equals(java.lang.String, java.lang.String)">equals</A></B>(java.lang.String&nbsp;path1,
       java.lang.String&nbsp;path2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Compares two local paths for equality.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#equals(java.lang.String, java.lang.String, boolean)">equals</A></B>(java.lang.String&nbsp;path1,
       java.lang.String&nbsp;path2,
       boolean&nbsp;forceIgnoreCase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Compares two local paths for equality, optionally forcing the comparison
 to ignore character case.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#expandTildeToHome(java.lang.String)">expandTildeToHome</A></B>(java.lang.String&nbsp;pathString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Expands any "~user" or "~" sequences in the given local path string to
 the absolute paths to those directories, preserving any trailing path
 parts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getCommonPathPrefix(java.lang.String, java.lang.String)">getCommonPathPrefix</A></B>(java.lang.String&nbsp;path1,
                    java.lang.String&nbsp;path2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given two canonicalized paths (that never end with a filesystem separator
 except for a drive letter root on Windows), returns the longest path
 prefix which is common to both paths.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getCurrentWorkingDirectory()">getCurrentWorkingDirectory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the full path to the current working directory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getDirectory(java.lang.String)">getDirectory</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the directory part of the local path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getFileExtension(java.lang.String)">getFileExtension</A></B>(java.lang.String&nbsp;localPath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the extension of the given local path -- everything from the last
 '.' of the file part (including the '.').</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getFileName(java.lang.String)">getFileName</A></B>(java.lang.String&nbsp;localPath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets just the file part of the given local path, which is all of the
 string after the last path component.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getFolderDepth(java.lang.String)">getFolderDepth</A></B>(java.lang.String&nbsp;localPath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calls <A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getFolderDepth(java.lang.String, com.microsoft.tfs.util.Platform)"><CODE>getFolderDepth(String, Platform)</CODE></A> with
 <CODE>Platform.getCurrentPlatform()</CODE> as the <CODE>Platform</CODE> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getFolderDepth(java.lang.String, com.microsoft.tfs.util.Platform)">getFolderDepth</A></B>(java.lang.String&nbsp;localPath,
               com.microsoft.tfs.util.Platform&nbsp;platform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Returns the depth of the item described by path, where the root folder is
 depth 0, items in root are 1, items below that are 2, etc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getHierarchy(java.lang.String)">getHierarchy</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all directories leading up to (and including) the given path,
 from the root of the local filesystem.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getLastComponent(java.lang.String)">getLastComponent</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the the last path component in the supplied path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getParent(java.lang.String)">getParent</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the parent directory name of the given local path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getPathRoot(java.lang.String)">getPathRoot</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the root portion of the given path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getPathRoot(java.lang.String, com.microsoft.tfs.util.Platform)">getPathRoot</A></B>(java.lang.String&nbsp;path,
            com.microsoft.tfs.util.Platform&nbsp;platform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getRootLength(java.lang.String)">getRootLength</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getRootLength(java.lang.String, com.microsoft.tfs.util.Platform)">getRootLength</A></B>(java.lang.String&nbsp;path,
              com.microsoft.tfs.util.Platform&nbsp;platform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the length of the root DirectoryInfo or whatever DirectoryInfo
 markers are specified for the first part of the DirectoryInfo name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#hashCode(java.lang.String)">hashCode</A></B>(java.lang.String&nbsp;localPath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a hash code for the given local path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#hasVersionControlReservedCharacter(java.lang.String, java.util.concurrent.atomic.AtomicReference)">hasVersionControlReservedCharacter</A></B>(java.lang.String&nbsp;path,
                                   java.util.concurrent.atomic.AtomicReference&lt;java.lang.Character&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the path contains any character which is a version
 control reserved character.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#isChild(java.lang.String, java.lang.String)">isChild</A></B>(java.lang.String&nbsp;parentPath,
        java.lang.String&nbsp;possibleChild)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Tests the given paths for a parent-child relationship.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#isDirectChild(java.lang.String, java.lang.String)">isDirectChild</A></B>(java.lang.String&nbsp;parentPath,
              java.lang.String&nbsp;possibleChild)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests whether one path is a direct child of another path (which would be
 the parent).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#isDirectoryEmpty(java.lang.String)">isDirectoryEmpty</A></B>(java.lang.String&nbsp;localPath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests whether a directory is empty (contains no files or directories).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#isPathRooted(java.lang.String)">isPathRooted</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests whether the given path starts with a drive root prefix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#isWildcard(java.lang.String)">isWildcard</A></B>(java.lang.String&nbsp;localPath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Tests whether the given local path contains wildcard characters in its
 final path element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#lastPartEqualsCaseSensitive(java.lang.String, java.lang.String)">lastPartEqualsCaseSensitive</A></B>(java.lang.String&nbsp;path1,
                            java.lang.String&nbsp;path2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compare two file paths in a platform-default-case-sensitivity fashion on
 every portion of the path except for the last item in the path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#makeRelative(java.lang.String, java.lang.String)">makeRelative</A></B>(java.lang.String&nbsp;localPath,
             java.lang.String&nbsp;relativeTo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Returns a new string describing the first given path made relative to the
 second given path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#makeServer(java.lang.String, java.lang.String, java.lang.String)">makeServer</A></B>(java.lang.String&nbsp;localPath,
           java.lang.String&nbsp;relativeToLocalPath,
           java.lang.String&nbsp;serverRoot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Maps a local path to a server path, given a parent local path of the path
 to be mapped, and a server path that corresponds to the parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#matchesWildcard(java.lang.String, java.lang.String, java.lang.String, boolean)">matchesWildcard</A></B>(java.lang.String&nbsp;firstItemPath,
                java.lang.String&nbsp;secondItemFolderPath,
                java.lang.String&nbsp;secondItemWildcardPattern,
                boolean&nbsp;recursive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Matches one item against a wildcard tuple (item path and wildcard pattern
 to apply to that item path), optionally allowing recursive matches.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#nativeToTFS(java.lang.String)">nativeToTFS</A></B>(java.lang.String&nbsp;localPath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts this platform's file path to TFS's preferred separator
 (backslash) and roots it in a DOS-style drive letter if not already
 rooted in one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#removeTrailingSeparators(java.lang.String)">removeTrailingSeparators</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the given path string without trailing separators (as specified
 by File.separator).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#startsWith(java.lang.String, java.lang.String)">startsWith</A></B>(java.lang.String&nbsp;path,
           java.lang.String&nbsp;prefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#tfsToNative(java.lang.String)">tfsToNative</A></B>(java.lang.String&nbsp;localPath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a TFS-style path into this platform's pathstyle.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="TFS_PREFERRED_LOCAL_PATH_SEPARATOR"><!-- --></A><H3>
TFS_PREFERRED_LOCAL_PATH_SEPARATOR</H3>
<PRE>
public static final char <B>TFS_PREFERRED_LOCAL_PATH_SEPARATOR</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../../constant-values.html#com.microsoft.tfs.core.clients.versioncontrol.path.LocalPath.TFS_PREFERRED_LOCAL_PATH_SEPARATOR">Constant Field Values</A><dt><b>Constant Field Value:</b></dt>
<dd><a href="../../../../../../../constant-values.html#com.microsoft.tfs.core.clients.versioncontrol.path.LocalPath.TFS_PREFERRED_LOCAL_PATH_SEPARATOR"><code>92</code></a></dd>
</DL>
</DL>
<HR>

<A NAME="TOP_DOWN_COMPARATOR"><!-- --></A><H3>
TOP_DOWN_COMPARATOR</H3>
<PRE>
public static final java.util.Comparator&lt;java.lang.String&gt; <B>TOP_DOWN_COMPARATOR</B></PRE>
<DL>
<DD>Compares well-formed local path strings in a top-down fashion (parents
 sort before their children).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="BOTTOM_UP_COMPARATOR"><!-- --></A><H3>
BOTTOM_UP_COMPARATOR</H3>
<PRE>
public static final java.util.Comparator&lt;java.lang.String&gt; <B>BOTTOM_UP_COMPARATOR</B></PRE>
<DL>
<DD>Compares well-formed local path strings in a bottom-up fashion (children
 sort before their parents).
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LocalPath()"><!-- --></A><H3>
LocalPath</H3>
<PRE>
public <B>LocalPath</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getCurrentWorkingDirectory()"><!-- --></A><H3>
getCurrentWorkingDirectory</H3>
<PRE>
public static final java.lang.String <B>getCurrentWorkingDirectory</B>()</PRE>
<DL>
<DD>Gets the full path to the current working directory.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the full path to the current working directory.</DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.String, java.lang.String)"><!-- --></A><H3>
equals</H3>
<PRE>
public static final boolean <B>equals</B>(java.lang.String&nbsp;path1,
                                   java.lang.String&nbsp;path2)</PRE>
<DL>
<DD><p>
 Compares two local paths for equality. Character case is honored when the
 operating system is case-sensitive (
 <CODE>FileHelpers.doesFileSystemIgnoreCase()</CODE>). Paths are not normalized
 (".." segments removed) before comparison.
 </p>
 <p>
 Two null paths are equal, but a null path does not equal a non-null path.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path1</CODE> - the first local path (may be <code>null</code>)<DD><CODE>path2</CODE> - the second local path (may be <code>null</code>)
<DT><B>Returns:</B><DD>true if the paths are equal, false if not.</DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.String, java.lang.String, boolean)"><!-- --></A><H3>
equals</H3>
<PRE>
public static final boolean <B>equals</B>(java.lang.String&nbsp;path1,
                                   java.lang.String&nbsp;path2,
                                   boolean&nbsp;forceIgnoreCase)</PRE>
<DL>
<DD><p>
 Compares two local paths for equality, optionally forcing the comparison
 to ignore character case. Paths are not normalized (".." segments
 removed) before comparison.
 </p>
 <p>
 Two null paths are equal, but a null path does not equal a non-null path.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path1</CODE> - the first local path (may be <code>null</code>)<DD><CODE>path2</CODE> - the second local path (may be <code>null</code>)<DD><CODE>forceIgnoreCase</CODE> - if <code>true</code>, case is always ignored in the comparison. If
        <code>false</code>, case is only ignored if
        <CODE>FileHelpers.doesFileSystemIgnoreCase()</CODE> returns
        <code>true</code><DT><B>See Also:</B><DD><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#hashCode(java.lang.String)"><CODE>hashCode(String)</CODE></A>
<DT><B>Returns:</B><DD>true if the paths are equal, false if not.</DL>
</DD>
</DL>
<HR>

<A NAME="startsWith(java.lang.String, java.lang.String)"><!-- --></A><H3>
startsWith</H3>
<PRE>
public static final boolean <B>startsWith</B>(java.lang.String&nbsp;path,
                                       java.lang.String&nbsp;prefix)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="endsWith(java.lang.String, java.lang.String)"><!-- --></A><H3>
endsWith</H3>
<PRE>
public static final boolean <B>endsWith</B>(java.lang.String&nbsp;path,
                                     java.lang.String&nbsp;suffix)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lastPartEqualsCaseSensitive(java.lang.String, java.lang.String)"><!-- --></A><H3>
lastPartEqualsCaseSensitive</H3>
<PRE>
public static final boolean <B>lastPartEqualsCaseSensitive</B>(java.lang.String&nbsp;path1,
                                                        java.lang.String&nbsp;path2)</PRE>
<DL>
<DD>Compare two file paths in a platform-default-case-sensitivity fashion on
 every portion of the path except for the last item in the path. The last
 item in the path is compared in a case-sensitive fashion.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path1</CODE> - the first local path (must not be <code>null</code>)<DD><CODE>path2</CODE> - the second local path (must not be <code>null</code>)<DT><B>See Also:</B><DD><CODE>FileHelpers.doesFileSystemIgnoreCase()</CODE>
<DT><B>Returns:</B><DD>true if the paths differ, false if they are the same</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(java.lang.String)"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static final int <B>hashCode</B>(java.lang.String&nbsp;localPath)</PRE>
<DL>
<DD>Returns a hash code for the given local path. This method for calculating
 hash codes must be used when <A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#equals(java.lang.String, java.lang.String)"><CODE>equals(String, String)</CODE></A> is
 used to test for equality so the case-sensitivity behavior matches (and
 the hashCode/equals contract is maintained).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>localPath</CODE> - the local path to compute the hash code for (must not be
        <code>null</code>)
<DT><B>Returns:</B><DD>the hash code value</DL>
</DD>
</DL>
<HR>

<A NAME="isDirectChild(java.lang.String, java.lang.String)"><!-- --></A><H3>
isDirectChild</H3>
<PRE>
public static boolean <B>isDirectChild</B>(java.lang.String&nbsp;parentPath,
                                    java.lang.String&nbsp;possibleChild)</PRE>
<DL>
<DD>Tests whether one path is a direct child of another path (which would be
 the parent).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parentPath</CODE> - the path to the parent folder (must not be <code>null</code>)<DD><CODE>possibleChild</CODE> - the path of the possible child item (must not be <code>null</code>
        )
<DT><B>Returns:</B><DD>true if the possibleChild is a direct child of the parentPath</DL>
</DD>
</DL>
<HR>

<A NAME="isChild(java.lang.String, java.lang.String)"><!-- --></A><H3>
isChild</H3>
<PRE>
public static final boolean <B>isChild</B>(java.lang.String&nbsp;parentPath,
                                    java.lang.String&nbsp;possibleChild)</PRE>
<DL>
<DD><p>
 Tests the given paths for a parent-child relationship. A path is a child
 of another if the object it describes would reside below the object
 described by the parent path in the local filesystem. Case is respected
 on a per-platform basis.
 <p>
 </p>
 A possible child that is equivalent to the parent path (both refer to the
 same object) is considered a child. This is compatible with Visual
 Studio's behavior. </p>
 <p>
 The given paths are not canonicalized before testing.
 </p>
 <p>
 The given paths must be in the OS's native path format.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parentPath</CODE> - the local path to the parent item (not null).<DD><CODE>possibleChild</CODE> - the local path of the possible child item (not null).
<DT><B>Returns:</B><DD>true if possibleChild is a child of parentPath, false otherwise
         (including I/O errors accessing either path).</DL>
</DD>
</DL>
<HR>

<A NAME="isDirectoryEmpty(java.lang.String)"><!-- --></A><H3>
isDirectoryEmpty</H3>
<PRE>
public static final boolean <B>isDirectoryEmpty</B>(java.lang.String&nbsp;localPath)</PRE>
<DL>
<DD>Tests whether a directory is empty (contains no files or directories).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>localPath</CODE> - the local directory path to test (must not be <code>null</code>)
<DT><B>Returns:</B><DD>true if the given path contains no directories or files, false if
         it contains directories or files.</DL>
</DD>
</DL>
<HR>

<A NAME="tfsToNative(java.lang.String)"><!-- --></A><H3>
tfsToNative</H3>
<PRE>
public static final java.lang.String <B>tfsToNative</B>(java.lang.String&nbsp;localPath)</PRE>
<DL>
<DD>Converts a TFS-style path into this platform's pathstyle. On Windows, the
 string is unaltered, on Unix the drive letter is removed and the
 backslashes are converted to slashes.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>localPath</CODE> - the TFS-style local path string to convert. If null, null is
        returned.
<DT><B>Returns:</B><DD>this platform's preferred style of local path string, null if the
         given localPath was null.</DL>
</DD>
</DL>
<HR>

<A NAME="nativeToTFS(java.lang.String)"><!-- --></A><H3>
nativeToTFS</H3>
<PRE>
public static final java.lang.String <B>nativeToTFS</B>(java.lang.String&nbsp;localPath)</PRE>
<DL>
<DD>Converts this platform's file path to TFS's preferred separator
 (backslash) and roots it in a DOS-style drive letter if not already
 rooted in one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>localPath</CODE> - the absolute local path string to convert to TFS-style separators.
        If null, null is returned.
<DT><B>Returns:</B><DD>the TFS-style path, which looks like an absolute Windows path
         name, null if the given localPath was null.</DL>
</DD>
</DL>
<HR>

<A NAME="getFolderDepth(java.lang.String)"><!-- --></A><H3>
getFolderDepth</H3>
<PRE>
public static int <B>getFolderDepth</B>(java.lang.String&nbsp;localPath)</PRE>
<DL>
<DD>Calls <A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getFolderDepth(java.lang.String, com.microsoft.tfs.util.Platform)"><CODE>getFolderDepth(String, Platform)</CODE></A> with
 <CODE>Platform.getCurrentPlatform()</CODE> as the <CODE>Platform</CODE> argument.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getFolderDepth(java.lang.String, com.microsoft.tfs.util.Platform)"><CODE>getFolderDepth(String, Platform)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFolderDepth(java.lang.String, com.microsoft.tfs.util.Platform)"><!-- --></A><H3>
getFolderDepth</H3>
<PRE>
public static int <B>getFolderDepth</B>(java.lang.String&nbsp;localPath,
                                 com.microsoft.tfs.util.Platform&nbsp;platform)</PRE>
<DL>
<DD><p>
 Returns the depth of the item described by path, where the root folder is
 depth 0, items in root are 1, items below that are 2, etc. UNC paths are
 supported on Windows, but are not supported on other platforms (an
 exception is thrown). The path must be absolute, well-formed, and must
 not contain . or .. segments.
 </p>
 <h3>UNC Paths</h3>
 <p>
 On Windows, UNC paths and drive letters are supported. In this case a
 string like "\\server\share\" is the root path (depth 0). If the share
 name part is not specified, <CODE>IllegalArgumentException</CODE> is thrown.
 </p>
 <p>
 On non-Windows platforms, parsing UNC and drive letter paths is undefined
 because those paths would not be valid absolute local paths (all absolute
 paths must start with "/" and UNC and drive letters do not).
 </p>
 <p>
 Safe for remote paths. Does not access the local disk or network shares.
 </p>
 <p>
 <ul>
 <li>\ will return 0</li>
 <li>\a will return 1</li>
 <li>c:\ will return 0</li>
 <li>c:\a will return 1</li>
 <li>c:\a\ will return 1</li>
 <li>c:\a\b will return 2</li>
 <li>c:\a\b\ will return 2</li>
 <li>c:\a\b\zap will return 3</li>
 <li>c:\a\b\zap\ will return 3</li>
 <li>\\localhost\share1 will return 0</li>
 <li>\\localhost\share1\ will return 0</li>
 <li>\\localhost\share1\a will return 1</li>
 <li>\\localhost\share1\a\ will return 1</li>
 <li>\\localhost\share1\a\bar will return 2</li>
 <li>\\localhost\share1\a\bar\ will return 2</li>
 <li>/ will return 0</li>
 <li>/a will return 1</li>
 <li>/a/ will return 1</li>
 <li>/a/b will return 2</li>
 <li>/a/b/ will return 2</li>
 <li>/a/b/zap will return 3</li>
 <li>/a/b/zap/ will return 3</li>
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>localPath</CODE> - the local path to test (not <code>null</code> or empty)<DD><CODE>platform</CODE> - the <CODE>Platform</CODE> whose path conventions should be used (must
        not be <code>null</code>)
<DT><B>Returns:</B><DD>the depth from root, where root is 0, first directories are 1,
         etc.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the path is not absolute, or is in an invalid format, or
         another argument requirement was not satisfied</DL>
</DD>
</DL>
<HR>

<A NAME="combine(java.lang.String, java.lang.String)"><!-- --></A><H3>
combine</H3>
<PRE>
public static final java.lang.String <B>combine</B>(java.lang.String&nbsp;parent,
                                             java.lang.String&nbsp;relative)</PRE>
<DL>
<DD>Combines the two given paths into one path string, using this platform's
 preferred path separator character. If relative is an absolute path, it
 is returned as the entire return value (parent is discarded).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parent</CODE> - the first (left-side) path component (must not be
        <code>null</code>)<DD><CODE>relative</CODE> - the second (right-side) path component (must not be
        <code>null</code>)</DL>
</DD>
</DL>
<HR>

<A NAME="getHierarchy(java.lang.String)"><!-- --></A><H3>
getHierarchy</H3>
<PRE>
public static java.lang.String[] <B>getHierarchy</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD>Returns all directories leading up to (and including) the given path,
 from the root of the local filesystem. Note that canonical parents are
 returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the path to get parent paths for (must not be <code>null</code>)
<DT><B>Returns:</B><DD>the canonical parent path strings</DL>
</DD>
</DL>
<HR>

<A NAME="getParent(java.lang.String)"><!-- --></A><H3>
getParent</H3>
<PRE>
public static java.lang.String <B>getParent</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD>Returns the parent directory name of the given local path. Note that this
 differs from <A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getDirectory(java.lang.String)"><CODE>getDirectory(String)</CODE></A> in that it will always return
 the parent path, regardless of whether path is a file or folder.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the local path (file or directory) to get the parent directory of
        (must not be <code>null</code>)
<DT><B>Returns:</B><DD>the parent directory of the given path.</DL>
</DD>
</DL>
<HR>

<A NAME="getDirectory(java.lang.String)"><!-- --></A><H3>
getDirectory</H3>
<PRE>
public static java.lang.String <B>getDirectory</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD>Returns the directory part of the local path. If the path describes a
 directory, the same path is returned. If the path describes a file, the
 path to its parent directory is returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the local path (file or directory) to get the directory part of
        (must not be <code>null</code>)
<DT><B>Returns:</B><DD>the directory part of the given path.</DL>
</DD>
</DL>
<HR>

<A NAME="getFileName(java.lang.String)"><!-- --></A><H3>
getFileName</H3>
<PRE>
public static java.lang.String <B>getFileName</B>(java.lang.String&nbsp;localPath)</PRE>
<DL>
<DD>Gets just the file part of the given local path, which is all of the
 string after the last path component. If there are no separators, the
 entire string is returned. If the string ends in a separator, an empty
 string is returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>localPath</CODE> - the local path from which to parse the file part (must not be
        <code>null</code>)
<DT><B>Returns:</B><DD>the file name at the end of the given local path, or the given
         path if no separator characters were found, or an empty string if
         the given path ends with a separator.</DL>
</DD>
</DL>
<HR>

<A NAME="getFileExtension(java.lang.String)"><!-- --></A><H3>
getFileExtension</H3>
<PRE>
public static java.lang.String <B>getFileExtension</B>(java.lang.String&nbsp;localPath)</PRE>
<DL>
<DD>Gets the extension of the given local path -- everything from the last
 '.' of the file part (including the '.'). If there is no dot, an empty
 string is returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>localPath</CODE> - the local path to parse the extension from (must not be
        <code>null</code>)
<DT><B>Returns:</B><DD>the file extension at the end of the given path, or an empty
         string if no extension separator ('.') exists.</DL>
</DD>
</DL>
<HR>

<A NAME="getLastComponent(java.lang.String)"><!-- --></A><H3>
getLastComponent</H3>
<PRE>
public static final java.lang.String <B>getLastComponent</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD>Return the the last path component in the supplied path. If an empty
 string is supplied for the path, an empty string is returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the path string to examine (must not be <code>null</code>)
<DT><B>Returns:</B><DD>the last path component of the given path string, which would be
         the file name if the path string references a file, and the
         directory furthest down the hierarchy if the path references a
         directory.</DL>
</DD>
</DL>
<HR>

<A NAME="compareTopDown(java.lang.String, java.lang.String)"><!-- --></A><H3>
compareTopDown</H3>
<PRE>
public static final int <B>compareTopDown</B>(java.lang.String&nbsp;pathA,
                                       java.lang.String&nbsp;pathB)</PRE>
<DL>
<DD>Compares two local paths (ordinal character comparison) placing children
 after their parents. Ignores case if the current platform does. Paths are
 not normalized (".." segments removed) before comparison.
 <p>
 If sorting paths for display to the user, better to use a
 <CODE>Collator</CODE>-based comparison instead of this one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pathA</CODE> - the first path to compare (must not be <code>null</code>)<DD><CODE>pathB</CODE> - the second path to compare (must not be <code>null</code>)<DT><B>See Also:</B><DD><CODE>FileHelpers.doesFileSystemIgnoreCase()</CODE>
<DT><B>Returns:</B><DD>see <CODE>Comparable.compareTo(Object)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="compareBottomUp(java.lang.String, java.lang.String)"><!-- --></A><H3>
compareBottomUp</H3>
<PRE>
public static final int <B>compareBottomUp</B>(java.lang.String&nbsp;pathA,
                                        java.lang.String&nbsp;pathB)</PRE>
<DL>
<DD>Compares two server paths (ordinal character comparison) placing parents
 after their children. Ignores case if the current platform does. Paths
 are not normalized (".." segments removed) before comparison.
 <p>
 If sorting paths for display to the user, better to use a
 <CODE>Collator</CODE>-based comparison instead of this one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pathA</CODE> - the first path to compare (must not be <code>null</code>)<DD><CODE>pathB</CODE> - the second path to compare (must not be <code>null</code>)<DT><B>See Also:</B><DD><CODE>FileHelpers.doesFileSystemIgnoreCase()</CODE>
<DT><B>Returns:</B><DD>see <CODE>Comparable.compareTo(Object)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="canonicalize(java.lang.String)"><!-- --></A><H3>
canonicalize</H3>
<PRE>
public static final java.lang.String <B>canonicalize</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD><p>
 Gets the canonical form of the given path. On Unix platforms (including
 Mac OS X), a path that begins with "~" or "~user", where user is a user
 name on this host, is expanded to the full path to the absolute path to
 the user's home directory (and any other path components, of course).
 </p>
 <p>
 On case-preserving but case-insensitive filesystems, this implementation
 differs from Java's <CODE>File.getCanonicalPath()</CODE> in one important way:
 if the given path string refers to a filesystem object (file or
 directory) that exists on disk but has a name (not path) that differs
 only in character case, the path is still made canonical according to
 <CODE>File.getCanonicalPath()</CODE> but the character case of the final path
 element (object's name) is taken from the given path. If the given path
 does not exist on disk, or does exist but the final elements have
 matching character case, the path returned by
 <CODE>File.getCanonicalPath()</CODE> is returned. This behavior allows us to
 make a relative path string "canonical" (in the <A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html" title="class in com.microsoft.tfs.core.clients.versioncontrol.path"><CODE>LocalPath</CODE></A> way)
 and support the case-changing rename case (where only the case of the
 file changes).
 </p>
 <p>
 On case-sensitive filesystems (most Unixes, not Mac OS X) this method
 behaves exactly like Java's <CODE>File.getCanonicalPath()</CODE>.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the path to canonicalize. If null is given, null is returned.
<DT><B>Returns:</B><DD>the canonical version of the given path, null if path was null.</DL>
</DD>
</DL>
<HR>

<A NAME="isWildcard(java.lang.String)"><!-- --></A><H3>
isWildcard</H3>
<PRE>
public static boolean <B>isWildcard</B>(java.lang.String&nbsp;localPath)</PRE>
<DL>
<DD><p>
 Tests whether the given local path contains wildcard characters in its
 final path element. Wildcards in initial path elements (intermediate
 directories) are ignored.
 </p>
 <p>
 Character case is ignored during wildcard matching.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>localPath</CODE> - the local path to test for wildcards (in last element only). Not
        null.
<DT><B>Returns:</B><DD>true if the last path element contains wildcards, false
         otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="matchesWildcard(java.lang.String, java.lang.String, java.lang.String, boolean)"><!-- --></A><H3>
matchesWildcard</H3>
<PRE>
public static final boolean <B>matchesWildcard</B>(java.lang.String&nbsp;firstItemPath,
                                            java.lang.String&nbsp;secondItemFolderPath,
                                            java.lang.String&nbsp;secondItemWildcardPattern,
                                            boolean&nbsp;recursive)</PRE>
<DL>
<DD><p>
 Matches one item against a wildcard tuple (item path and wildcard pattern
 to apply to that item path), optionally allowing recursive matches.
 </p>
 <p>
 Character case is ignored during wildcard matching.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>firstItemPath</CODE> - the item to test against the wildcard pattern. This is a full path
        (must not be <code>null</code>)<DD><CODE>secondItemFolderPath</CODE> - a path where the wildcard pattern will be applied to find the item
        described by firstItemPath. If this parameter is a child of
        firstItemPath, there wildcard pattern will never match. If this
        parameter is a direct parent of firstItemPath, the wildcard can
        match. If this parameter is a grandparent (or greater), the
        pattern can only match if the recursive parameter is true. If this
        parameter is null, false is returned.<DD><CODE>secondItemWildcardPattern</CODE> - the wildcard pattern to apply to secondItemFolderPath.<DD><CODE>recursive</CODE> - if true, the wildcard pattern will apply to secondItemFolderPath
        and all its possible children. If false, the wildcard pattern will
        only match direct children of secondItemFolderPath.
<DT><B>Returns:</B><DD>true if the firstItemPath matches the wildcard specification,
         false if it does not.</DL>
</DD>
</DL>
<HR>

<A NAME="makeRelative(java.lang.String, java.lang.String)"><!-- --></A><H3>
makeRelative</H3>
<PRE>
public static java.lang.String <B>makeRelative</B>(java.lang.String&nbsp;localPath,
                                            java.lang.String&nbsp;relativeTo)</PRE>
<DL>
<DD><p>
 Returns a new string describing the first given path made relative to the
 second given path.
 </p>
 <p>
 Character case is ignored during string comparison, so strings with
 mismatched-in-case common elements will still succeed in being made
 relative.
 </p>
 <p>
 Paths are not normalized (for ending separators, case, etc.). It is the
 caller's responsibility to make sure the relativeTo path can be matched.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>localPath</CODE> - the path to the local item to describe (must not be
        <code>null</code>)<DD><CODE>relativeTo</CODE> - the path that the first parameter will be described relative to
        (must not be <code>null</code>)
<DT><B>Returns:</B><DD>the relative path, or the unaltered given local path if it could
         not be made relative to the second path.</DL>
</DD>
</DL>
<HR>

<A NAME="makeServer(java.lang.String, java.lang.String, java.lang.String)"><!-- --></A><H3>
makeServer</H3>
<PRE>
public static java.lang.String <B>makeServer</B>(java.lang.String&nbsp;localPath,
                                          java.lang.String&nbsp;relativeToLocalPath,
                                          java.lang.String&nbsp;serverRoot)</PRE>
<DL>
<DD><p>
 Maps a local path to a server path, given a parent local path of the path
 to be mapped, and a server path that corresponds to the parent.
 </p>
 <p>
 Character case is ignored during string comparison, so strings with
 mismatched-in-case common elements will still succeed in being made
 relative.
 </p>
 <p>
 Paths are not normalized (for ending separators, case, etc.). It is the
 caller's responsibility to make sure the relativeToLocalPath path can be
 matched.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>localPath</CODE> - the local path to convert to a server path (must not be
        <code>null</code>)<DD><CODE>relativeToLocalPath</CODE> - the parent local path (must not be <code>null</code> and must be a
        parent of <code>localPath</code>)<DD><CODE>serverRoot</CODE> - the server path that corresponds to
        <code>relativeToLocalPath</code> (must not be <code>null</code>)
<DT><B>Returns:</B><DD>the corresponding server path (never <code>null</code>)</DL>
</DD>
</DL>
<HR>

<A NAME="removeTrailingSeparators(java.lang.String)"><!-- --></A><H3>
removeTrailingSeparators</H3>
<PRE>
public static java.lang.String <B>removeTrailingSeparators</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD>Returns the given path string without trailing separators (as specified
 by File.separator).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the string to strip trailing separators from.
<DT><B>Returns:</B><DD>the given string with all trailing separators removed.</DL>
</DD>
</DL>
<HR>

<A NAME="expandTildeToHome(java.lang.String)"><!-- --></A><H3>
expandTildeToHome</H3>
<PRE>
protected static java.lang.String <B>expandTildeToHome</B>(java.lang.String&nbsp;pathString)</PRE>
<DL>
<DD><p>
 Expands any "~user" or "~" sequences in the given local path string to
 the absolute paths to those directories, preserving any trailing path
 parts. The JNI home directory lookup is only performed if this platform
 is not Windows and the "~user" format is encountered.
 </p>
 <p>
 Also, leading whitespace is always removed from the given path string.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pathString</CODE> - the path string to expand for tildes (must not be
        <code>null</code>)
<DT><B>Returns:</B><DD>the path string with "~user" and "~" expanded; the given string
         is returned unaltered (except for the removal of leading
         whitespace) if the username cannot be found or does not start
         with a "~".</DL>
</DD>
</DL>
<HR>

<A NAME="checkLocalItem(java.lang.String, java.lang.String, boolean, boolean, boolean, boolean)"><!-- --></A><H3>
checkLocalItem</H3>
<PRE>
public static <A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/ItemValidationError.html" title="class in com.microsoft.tfs.core.clients.versioncontrol.path">ItemValidationError</A> <B>checkLocalItem</B>(java.lang.String&nbsp;item,
                                                 java.lang.String&nbsp;parameterName,
                                                 boolean&nbsp;allowNull,
                                                 boolean&nbsp;allowWildcards,
                                                 boolean&nbsp;allow8Dot3Paths,
                                                 boolean&nbsp;checkReservedCharacters)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hasVersionControlReservedCharacter(java.lang.String, java.util.concurrent.atomic.AtomicReference)"><!-- --></A><H3>
hasVersionControlReservedCharacter</H3>
<PRE>
public static boolean <B>hasVersionControlReservedCharacter</B>(java.lang.String&nbsp;path,
                                                         java.util.concurrent.atomic.AtomicReference&lt;java.lang.Character&gt;&nbsp;c)</PRE>
<DL>
<DD>Returns true if the path contains any character which is a version
 control reserved character.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the string to check for invalid characters (must not be
        <code>null</code>)<DD><CODE>c</CODE> - a reference to a <CODE>Character</CODE> where the invalid detected
        character will be stored if the method returns <code>true</code>
        (no character is stored if the method returns <code>false</code> )
        (may be <code>null</code>)
<DT><B>Returns:</B><DD>true if the path contains any version control reserved
         characters, false if it does not</DL>
</DD>
</DL>
<HR>

<A NAME="check8Dot3Aliases(java.lang.String)"><!-- --></A><H3>
check8Dot3Aliases</H3>
<PRE>
public static void <B>check8Dot3Aliases</B>(java.lang.String&nbsp;item)</PRE>
<DL>
<DD>Checks whether the given item contains any 8.3 aliases and throws if it
 does.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isPathRooted(java.lang.String)"><!-- --></A><H3>
isPathRooted</H3>
<PRE>
public static boolean <B>isPathRooted</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD>Tests whether the given path starts with a drive root prefix. A path is
 considered rooted if it starts with a backslash
 ("\"), slash ("/"), or a drive letter and a colon (":"). The Java File
 roots list is not consulted.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the local path to test (may be <code>null</code>)
<DT><B>Returns:</B><DD>true if the path is rooted, false otherwise (including if the
         path was <code>null</code> or empty)</DL>
</DD>
</DL>
<HR>

<A NAME="getPathRoot(java.lang.String)"><!-- --></A><H3>
getPathRoot</H3>
<PRE>
public static java.lang.String <B>getPathRoot</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD>Returns the root portion of the given path. The resulting string consists
 of those rightmost characters of the path that constitute the root of the
 path. Possible patterns for the resulting string are: An empty string (a
 relative path on the current drive), "/" an absolute Unix path, "\" (an
 absolute path on the current drive), "X:" (a relative path on a given
 drive, where X is the drive letter),
 "X:\" (an absolute path on a given drive), and "\\server\share" (a UNC
 path for a given server and share name). The resulting string is
 <code>null</code> if path is <code>null</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the path to get the root for (may be <code>null</code>)
<DT><B>Returns:</B><DD>the root portion of the path (<code>null</code> if a
         <code>null</code> path was given)</DL>
</DD>
</DL>
<HR>

<A NAME="getPathRoot(java.lang.String, com.microsoft.tfs.util.Platform)"><!-- --></A><H3>
getPathRoot</H3>
<PRE>
protected static java.lang.String <B>getPathRoot</B>(java.lang.String&nbsp;path,
                                              com.microsoft.tfs.util.Platform&nbsp;platform)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRootLength(java.lang.String)"><!-- --></A><H3>
getRootLength</H3>
<PRE>
protected static int <B>getRootLength</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html#getRootLength(java.lang.String, com.microsoft.tfs.util.Platform)"><CODE>getRootLength(String, Platform)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRootLength(java.lang.String, com.microsoft.tfs.util.Platform)"><!-- --></A><H3>
getRootLength</H3>
<PRE>
protected static int <B>getRootLength</B>(java.lang.String&nbsp;path,
                                   com.microsoft.tfs.util.Platform&nbsp;platform)</PRE>
<DL>
<DD>Gets the length of the root DirectoryInfo or whatever DirectoryInfo
 markers are specified for the first part of the DirectoryInfo name.
 
 From the .NET Path class implementation, but with NTFS validity
 enforcements on all platforms because we might send the chars to TFS
 later.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the local path to get the root length for (must not be
        <code>null</code>)<DD><CODE>platform</CODE> - the <CODE>Platform</CODE> whose path conventions should be used (must
        not be <code>null</code>)</DL>
</DD>
</DL>
<HR>

<A NAME="checkForIllegalDollarInPath(java.lang.String)"><!-- --></A><H3>
checkForIllegalDollarInPath</H3>
<PRE>
public static void <B>checkForIllegalDollarInPath</B>(java.lang.String&nbsp;path)</PRE>
<DL>
<DD>This method throws an InvalidPathException if there is a dollar sign
 ('$') that follows a path separator ('/' or '\') since no part of a path
 is allowed to start with a dollar sign.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the path to check (path must already be canonicalized)</DL>
</DD>
</DL>
<HR>

<A NAME="getCommonPathPrefix(java.lang.String, java.lang.String)"><!-- --></A><H3>
getCommonPathPrefix</H3>
<PRE>
public static java.lang.String <B>getCommonPathPrefix</B>(java.lang.String&nbsp;path1,
                                                   java.lang.String&nbsp;path2)</PRE>
<DL>
<DD>Given two canonicalized paths (that never end with a filesystem separator
 except for a drive letter root on Windows), returns the longest path
 prefix which is common to both paths.
 <p>
 <ul>
 <li>The computed common prefix will end with a directory separator if
 both input strings contained separators at that index.</li>
 <li>The computed common prefix will not end with a directory separator if
 one or both of the input strings did not contain a separator at the
 position that follows the common prefix text.</li>
 <li>On Windows, which has drive letters, there will always be a non-
 <code>null</code> prefix for files that reside on the same drive: the
 drive letter and a trailing backslash and possibly more directory parts.</li>
 <li>On Unix, two files at the root directory ("/") have no directory name
 parts preceding them (the slash is not properly a directory name), but it
 would be confusing to return <code>null</code> in this case since these
 paths do have a common parent, so "/" is returned.
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path1</CODE> - the first path (must not be <code>null</code> or empty)<DD><CODE>path2</CODE> - the second path (must not be <code>null</code> or empty)
<DT><B>Returns:</B><DD>longest path prefix common to both paths. <code>null</code> if
         the paths have nothing in common</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LocalPath.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/ItemValidationError.html" title="class in com.microsoft.tfs.core.clients.versioncontrol.path"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../../com/microsoft/tfs/core/clients/versioncontrol/path/ServerPath.html" title="class in com.microsoft.tfs.core.clients.versioncontrol.path"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../../index.html?com/microsoft/tfs/core/clients/versioncontrol/path/LocalPath.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LocalPath.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
&copy; 2012 Microsoft. All rights reserved.
</BODY>
</HTML>
